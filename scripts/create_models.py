#!/usr/bin/python

##
# @file create_models.py
# @author Eric Turner <elturner@eecs.berkeley.edu>
#
# @section DESCRIPTION
#
# This script will generate all modeling products, such as pointclouds,
# floorplans, and 3D models.  This should be called after the localization
# is completed for a dataset.
#
# Usage:
#
#	python create_models.py <path_to_dataset> <localization_file>
#

import os
import sys
import shutil
import subprocess

# Get the location of this file
SCRIPT_LOCATION = os.path.dirname(__file__)

# Import our python files
PYTHON_SRC_DIR = os.path.abspath(os.path.join(SCRIPT_LOCATION, \
                                 '..', 'src','python'))
PYTHON_FILES_DIR    = os.path.join(PYTHON_SRC_DIR, 'files')
PYTHON_CONFIG_DIR   = os.path.join(PYTHON_SRC_DIR, 'config')
PYTHON_GEOMETRY_DIR = os.path.join(PYTHON_SRC_DIR, 'geometry')
sys.path.append(PYTHON_SRC_DIR)
sys.path.append(PYTHON_FILES_DIR)
sys.path.append(PYTHON_CONFIG_DIR)
sys.path.append(PYTHON_GEOMETRY_DIR)
import config
import floorplan
import dataset_filepaths

###################################
##### PARSE COMMAND ARGUMENTS #####
###################################

# check that we were given a command-line argument
if len(sys.argv) != 3:
	print ""
	print " Usage:"
	print ""
	print "\t",sys.argv[0],"<path_to_dataset>","<localization_file>"
	print ""
	sys.exit(1)

# Get the dataset directory from command-line
DATASET_DIR = sys.argv[1]

# verify this is a valid folder
if not os.path.exists(DATASET_DIR):
	print "Error!  This is not a valid directory:",DATASET_DIR
	sys.exit(2)

# Get the output file from localization
LOCALIZATION_FILE = sys.argv[2]
if not os.path.exists(LOCALIZATION_FILE):
	print "Error! This is not a valid file:",LOCALIZATION_FILE
	sys.exit(3)

# get the human-friendly name of this dataset from the input file
(loc_file_head, loc_file_tail) = os.path.split(LOCALIZATION_FILE)
(DATASET_NAME, loc_file_ext) = os.path.splitext(loc_file_tail)

################################
##### Executable Locations #####
################################

# Set the location of the binaries
EXE_DIR = os.path.join(SCRIPT_LOCATION,'..','bin')

# The following locations are relative paths from the 'scripts/' folder
POINTCLOUD_EXE = os.path.abspath(os.path.join(EXE_DIR,  "pointcloud_gen"))
PART_PC_LEVELS_EXE = os.path.abspath(os.path.join(EXE_DIR, \
                                     "partition_pointcloud_levels"))
if sys.platform == 'win32' :
	POINTCLOUD_EXE     += '.exe'
	PART_PC_LEVELS_EXE += '.exe'

# Verify that these executables exist
if not os.path.exists(POINTCLOUD_EXE):
	print "Error!  Could not find pointcloud", \
		"generation executable:", \
		POINTCLOUD_EXE
	sys.exit(4)

if not os.path.exists(PART_PC_LEVELS_EXE):
	print "Error!  Could not find", \
	      "pointcloud level partitioning executable:", \
	      PART_PC_LEVELS_EXE
	sys.exit(5)

################################
##### Input File Locations #####
################################

# These files are generated by the data acquisition, preprocessing,
# or localization.  They are assumed to be in the following locations.
hardware_config_xml     = os.path.join("config","backpack_config.xml")
time_sync_xml           = os.path.join("time","time_sync.xml")

# These are sensor-specific files and values
up_geom_scanner_name       = "H1214157"
up_geom_scanner_datafile   = os.path.join("data","urg", \
					up_geom_scanner_name, \
                                       "urg_" + up_geom_scanner_name \
                                       + "_scandata.dat")
down_geom_scanner_name     = "H1311822"
down_geom_scanner_datafile = os.path.join("data","urg", \
					down_geom_scanner_name, \
					"urg_" + down_geom_scanner_name \
					+ "_scandata.dat")
left_camera_dir         = os.path.join("data", "dalsa", "left_camera", \
                                       "color")
left_camera_metadata    = os.path.join("data", "dalsa", "left_camera", \
                                       "color_left_camera_metadata.txt")
left_camera_calib       = os.path.join("calib", "camera", "intrinsic", \
                                       "ocam_calib_left.dat")
right_camera_dir         = os.path.join("data","dalsa","right_camera", \
                                        "color")
right_camera_metadata    = os.path.join("data", "dalsa", \
                                        "right_camera", \
                                        "color_right_camera_metadata.txt")
right_camera_calib       = os.path.join("calib", "camera", "intrinsic", \
                                        "ocam_calib_right.dat")
back_camera_dir          = os.path.join("data","dalsa","back_camera", \
                                        "color")
back_camera_metadata     = os.path.join("data", "dalsa", \
                                        "back_camera", \
                                        "color_back_camera_metadata.txt")
back_camera_calib        = os.path.join("calib", "camera", "intrinsic", \
                                        "ocam_calib_back.dat")

#################################
##### Output File Locations #####
#################################

# The following folders will contain the output files of this script,
# so we need to verify that they exist
MODELS_DIR     = os.path.join(DATASET_DIR, "models")
if not os.path.exists(MODELS_DIR):
	os.makedirs(MODELS_DIR)

POINTCLOUD_DIR = os.path.join(MODELS_DIR, "pointclouds")
if not os.path.exists(POINTCLOUD_DIR):
	os.makedirs(POINTCLOUD_DIR)

PC_LEVELS_DIR  = os.path.join(POINTCLOUD_DIR, "levels")
if not os.path.exists(PC_LEVELS_DIR):
	os.makedirs(PC_LEVELS_DIR)

# The following files will be generated by the executables called by
# this script
mad_file        = LOCALIZATION_FILE
xyz_file        = os.path.join(POINTCLOUD_DIR, DATASET_NAME + "_full.xyz")
xyz_levels      = os.path.join(PC_LEVELS_DIR,  DATASET_NAME + "_level_")
xyz_hist        = os.path.join(PC_LEVELS_DIR,  DATASET_NAME + "_hist.m")

####################
##### RUN CODE #####
####################

print "#### GENERATING FILES FOR %s ####" % DATASET_NAME
print ""

#################################
##### POINTCLOUD GENERATION #####
#################################

print "##### creating colored pointcloud #####"
ret = subprocess.call([POINTCLOUD_EXE, \
                      "-c", hardware_config_xml, \
                      "-f", left_camera_metadata, left_camera_calib, \
                            left_camera_dir, \
                      "-f", right_camera_metadata, right_camera_calib, \
                            right_camera_dir, \
                      "-f", back_camera_metadata, back_camera_calib, \
                            back_camera_dir, \
                      "-l", up_geom_scanner_name, \
		      		up_geom_scanner_datafile, \
                      "-l", down_geom_scanner_name, \
		      		down_geom_scanner_datafile, \
                      "-o", xyz_file, \
                      "-p", LOCALIZATION_FILE, \
                      "-t", time_sync_xml, \
                      "-u", "1000"], \
                      executable=POINTCLOUD_EXE, cwd=DATASET_DIR, \
                      stdout=None, stderr=None, stdin=None, shell=False)
if ret != 0:
	print "Error! Pointcloud generation program returned",ret
	sys.exit(6)

###################################
##### POINTCLOUD PARTITIONING #####
###################################

print "##### partitioning pointcloud into different floors #####"
ret = subprocess.call([PART_PC_LEVELS_EXE, \
                      "-o", xyz_levels, mad_file, \
                      xyz_file, xyz_hist], \
                      executable=PART_PC_LEVELS_EXE, cwd=DATASET_DIR, \
                      stdout=None, stderr=None, stdin=None, shell=False)
if ret != 0:
	print "Error! Pointcloud partitioning program returned",ret
	sys.exit(7)

######################
##### FLOORPLANS #####
######################

# iterate through the different levels of the building
for level_xyz_file in dataset_filepaths.get_pc_levels_list(DATASET_DIR): 

	# generate floorplan for this level
	ret = floorplan.run(DATASET_DIR, mad_file, level_xyz_file)
	if ret != 0:
		print "Error! Could not generate floorplans:",ret
		sys.exit(8)



#ifndef REGION_ISOSTUFFER_H
#define REGION_ISOSTUFFER_H

/**
 * @file   region_isostuffer.h
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 * @brief  Performs 2D isosurface stuffing for planar region geometry
 *
 * @section DESCRIPTION
 *
 * This file contains the region_isostuffer_t class, which is
 * used to represent the mesh generated by running 2D isosurface
 * stuffing on a planar region in order to represent its geometry
 * in a final model.
 *
 * Note that this technique was original used in Turner and Zakhor 2013,
 * at 3DV 2013.
 */

#include <geometry/shapes/plane.h>
#include <geometry/octree/octree.h>
#include <geometry/octree/octtopo.h>
#include <geometry/quadtree/quadtree.h>
#include <mesh/surface/region_mesher.h>
#include <mesh/surface/node_boundary.h>
#include <mesh/surface/node_corner.h>
#include <image/color.h>
#include <io/mesh/mesh_io.h>
#include <Eigen/Dense>
#include <iostream>
#include <map>

/**
 * The region isostuffer class is used to generate a 2D mesh for
 * a given planar region based on its composing faces.
 *
 * This is performed by generating a quadtree in 2D that is aligned
 * with the originating octree that generated the planar region.  The
 * faces of the region are projected onto the quadtree, so that the
 * interior can be represented by an efficient number of elements.
 */
class region_isostuffer_t
{
	/* parameters */
	private:

		/**
		 * This quadtree is used to represent the
		 * projected geometry of a planar region.
		 *
		 * The region is composed of axis-aligned faces,
		 * which are projected into the quadtree.  The
		 * quadtree elements are then simplified to
		 * represent the same area with an efficient
		 * number of elements.
		 */
		quadtree_t quadtree;

		/**
		 * The plane of the region that is being modeled
		 *
		 * It is necessary to store the plane, so that during
		 * triangulation we can project the 2D quadtree points
		 * back onto the plane in 3D space.
		 */
		plane_t plane;

		/**
		 * This matrix represents the projection matrix
		 * from 3D coordinates to the 2D quadtree coordinates.
		 *
		 * This value is dependant on the dominant face
		 * direction of the region being modeled.
		 */
		Eigen::Matrix<double, 2, 3> M;

		/**
		 * This vector indicates the direction along which
		 * the region is projected onto the quadtree.
		 *
		 * This vector represents the null space of M.
		 */
		Eigen::Vector3d nullspace;

		/**
		 * This mapping represents the transitions from quadtree
		 * corners to 3D mesh vertex indices.
		 *
		 * Since we want the final mesh to be topologically closed,
		 * we need for overlapping corners to represent the same
		 * vertex.  As such, we need to keep track if a given corner
		 * has been seen before.  If so, we want to know the
		 * existing vertex index to use.
		 */
		std::map<node_corner::corner_t, size_t> vert2d_ind; 

	/* functions */
	public:

		/*--------------*/
		/* constructors */
		/*--------------*/
		
		/* Since this class contains Eigen structures, we
		 * need to properly align memory */
		EIGEN_MAKE_ALIGNED_OPERATOR_NEW

		/**
		 * Clears all information from this structure
		 */
		void clear();

		/*------------*/
		/* processing */
		/*------------*/

		/**
		 * Initializes this structure based on the
		 * given octree and region.
		 *
		 * The quadtree representation stored in this
		 * object will be cleared and regenerated based
		 * on the input region.  The quadtree is assumed
		 * to be embedded in an axis-aligned plane with
		 * the octree, in an orientation that is the same
		 * as the dominant face direction of the region.
		 *
		 * The quadtree is populated to mimick the interior
		 * area of the region, so that it can be triangulated
		 * efficiently.
		 *
		 * @param octree      The originating octree for this model
		 * @param reginfo     The region info to analyze
		 * @param vert3d_ind  Mapping between existing vertices 
		 *                    (in 3D) to vertex indices.
		 *
		 * @return    Returns zero on success, non-zero on failure.
		 */
		int populate(const octree_t& octree, 
				const region_mesher::region_info_t& reginfo,
				const std::map<node_corner::corner_t, 
						size_t>& vert3d_ind);

		/**
		 * Computes the vertices of this quadtree, stores in mesh
		 *
		 * Assuming that the populate() function has already been
		 * called, will generate a set of vertices that represent
		 * the corners of the nodes in the representing quadtree
		 * of this region, and store the 3D positions of those
		 * vertices into the given mesh.
		 *
		 * This does NOT produce any triangles.  In order to
		 * do that, triagulate() must be called after this function.
		 *
		 * @param mesh    The mesh to add elements to
		 * @param color   The color to assign each vertex
		 * @param q       The root of the tree to write.  If null,
		 *                will use the root of the quadtree of this
		 *                object.
		 *
		 * @return    Returns zero on success, non-zero on failure.
		 */
		int compute_verts(mesh_io::mesh_t& mesh,
				const color_t& color,
				quadnode_t* q=NULL);

		/**
		 * Generates a triangulation of the generated quadtree
		 *
		 * Assuming that the populate() function has already been
		 * called, will generate a triangulation of the quadtree
		 * that will be stored in the given mesh.
		 *
		 * @param mesh The mesh to add elements to
		 * @param color   The color to assign each vertex
		 * @param q    The root of the tree to write.  If null,
		 *             will use the root of the quadtree of this
		 *             object.
		 *
		 * @return    Returns zero on success, non-zero on failure.
		 */
		int triangulate(mesh_io::mesh_t& mesh,
				const color_t& color,
				quadnode_t* q=NULL);

		/*-----------*/
		/* debugging */
		/*-----------*/

		/**
		 * Exports the 2D geometry of this projected to the 
		 * specified Wavefront OBJ file stream.
		 *
		 * @param os   The output stream to write to
		 * @param q    The root of the tree to write.  If null,
		 *             will use the root of the quadtree of this
		 *             object.
		 */
		void writeobj(std::ostream& os, quadnode_t* q = NULL) const;

	/* helper functions */
	private:

		/**
		 * Computes mapping matrix for given face direction
		 *
		 * Computes the matrix that maps from world
		 * coordinates onto the surface coordinates
		 * of a region that is represented by the
		 * specified by the given dominant face.
		 *
		 * Example:
		 *
		 * if f = FACE_ZPLUS, then:
		 *
		 *	[x_r;y_r] = [1,0,0; 0,1,0] * [x_w;y_w;z_w]
		 *
		 * @param f   The face that specifies the mapping
		 */
		void mapping_matrix(octtopo::CUBE_FACE f);

		/**
		 * Checks if the given face is a boundary face of the region
		 *
		 * Given a node_face_t and the mapping of which corners
		 * are boundaries, this function will check if the given
		 * face contains any boundary corners.
		 *
		 * If so, then it will be considered a boundary face.
		 *
		 * @param f            The face to check
		 * @param tree         The originating tree of this model
		 * @param vert3d_ind   The map of existing boundary corners
		 *
		 * @return   Returns true iff f is a bounary face.
		 */
		bool is_boundary_face(const node_face_t& f,
				const octree_t& tree,
				const std::map<node_corner::corner_t,
						size_t>& vert3d_ind) const;
};

#endif

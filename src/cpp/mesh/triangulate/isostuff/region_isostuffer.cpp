#include "region_isostuffer.h"
#include <geometry/shapes/plane.h>
#include <geometry/octree/octree.h>
#include <geometry/octree/octtopo.h>
#include <geometry/quadtree/quadtree.h>
#include <mesh/surface/region_mesher.h>
#include <mesh/surface/planar_region.h>
#include <mesh/surface/node_boundary.h>
#include <mesh/surface/node_corner.h>
#include <io/mesh/mesh_io.h>
#include <image/color.h>
#include <util/error_codes.h>
#include <Eigen/Dense>
#include <iostream>
#include <map>

/**
 * @file   region_isostuffer.cpp
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 * @breif  Performs 2D isosurface stuffing for planar region geometry
 *
 * @section DESCRIPTION
 *
 * This file contains the region_isostuffer_t class, which is
 * used to represent the mesh generated by running 2D isosurface
 * stuffing on a planar region in order to represent its geometry
 * in a final model.
 *
 * Note that this technique was original used in Turner and Zakhor 2013,
 * at 3DV 2013.
 */

using namespace std;
using namespace Eigen;
using namespace node_corner;

/*--------------------------*/
/* function implementations */
/*--------------------------*/

void region_isostuffer_t::clear()
{
	/* clear all info */
	this->quadtree.clear();
	this->vert2d_ind.clear();
}
		
int region_isostuffer_t::populate(const octree_t& octree, 
				const region_mesher::region_info_t& reginfo,
				const map<corner_t, size_t>& vert3d_ind)
{
	map<corner_t, size_t>::const_iterator vit;
	cornerset_t::const_iterator cit;
	faceset_t::const_iterator fit;
	octtopo::CUBE_FACE f, opp_f;
	Vector3d p3d;
	Vector2d center, p2d;
	corner_t corner2;
	double radius, res, hw;

	/* clear any existing info */
	this->clear();

	/* get the properties of this region (size and orientation) */
	const planar_region_t& region = reginfo.get_region();
	f = region.find_dominant_face();
	opp_f = octtopo::get_opposing_face(f);
	this->mapping_matrix(f);
	this->plane = region.get_plane();

	/* prepare to construct quadtree:
	 *
	 * get the radius as a power of two of the resolution 
	 * map center to 2D coordinates */
	res = octree.get_resolution();
	radius = octree.get_root()->halfwidth;
	center = this->M * octree.get_root()->center;

	/* we are going to use a quadtree to generate the mesh of this
	 * region.  This is the same method used in Turner and Zakhor
	 * at 3DV 2013. */
	this->quadtree.set(res, center, radius);

	/* iterate over the boundary vertices of this region */
	for(cit = reginfo.begin(); cit != reginfo.end(); cit++)
	{
		/* this corner should be a boundary vertex */
		vit = vert3d_ind.find(*cit);
		if(vit == vert3d_ind.end())
		{
			/* this map should have all vertices defined,
			 * something went wrong here */
			return -1;
		}

		/* get the position of this corner in 3D space */
		cit->get_position(octree, p3d);

		/* compute projected position onto 2D space */
		p2d = this->M * p3d;

		/* get corner discretization in 2D */
		corner2.set(center, res, p2d); 

		/* store in local map */
		this->vert2d_ind.insert(pair<corner_t, size_t>(
					corner2, vit->second));	
	}

	/* iterate over the faces of this region */
	for(fit = region.begin(); fit != region.end(); fit++)
	{
		/* check if it is oriented correctly */
		if(fit->direction != f && fit->direction != opp_f)
			continue; /* ignore non-dominant faces */

		/* we want to add the geometry of this face
		 * to the geometry of the quadtree. First, we
		 * need to get its projected position and size */
		fit->get_center(p3d);
		hw = fit->get_halfwidth();
		p2d = this->M * p3d;
		
		/* add this area to the quadtree */
		this->quadtree.subdivide(p2d, hw);
	}

	/* now that we've populated the quadtree with all
	 * the appropriate faces of this region, we want to
	 * simplify the quadtree geometry to ensure minimal
	 * triangles are used to represent the planar region. */
	quadtree.simplify();

	/* the quadtree now represents the interior area
	 * of the region */
	return 0;
}
		
int region_isostuffer_t::triangulate(mesh_io::mesh_t& mesh,
				const map<corner_t, size_t>& vert3d_ind,
				quadnode_t* q)
{
	size_t v_inds[quadnode_t::CHILDREN_PER_QUADNODE];
	map<corner_t, size_t>::const_iterator vit;
	Vector2d pts2d;
	Vector3d pts3d;
	corner_t corner;
	mesh_io::vertex_t vert;
	mesh_io::polygon_t poly;
	size_t i;
	int ret;

	/* check arguments */
	if(q == NULL)
		q = this->quadtree.get_root();

	/* only triangulate leaf nodes */
	if(q->isleaf())
	{
		/* iterate over each corner */
		for(i = 0; i < quadnode_t::CHILDREN_PER_QUADNODE; i++)
		{
			/* get position of corners of node */
			pts2d = q->corner_position(i);
			corner.set(this->quadtree.get_root()->center,
				this->quadtree.get_resolution(),
				pts2d);

			/* get info about this corner */
			vit = this->vert2d_ind.find(corner);
			if(vit == this->vert2d_ind.end())
			{
				/* This is a new vertex, internal only
				 * to this region.  Figure
				 * out its geometry:
				 *
				 * Its 3D position is found
				 * by projecting onto the plane */
				pts3d = M.transpose() * pts2d;
				this->plane.get_intersection_of(pts3d, 
						pts3d, this->nullspace);
				
				/* add it to the mesh */
				vert.x = pts3d(0);
				vert.y = pts3d(1);
				vert.z = pts3d(2);
				v_inds[i] = mesh.num_verts();
				mesh.add(vert);

				/* add it to the vert map */
				this->vert2d_ind.insert(
					pair<corner_t, size_t>(
						corner, v_inds[i]));
			}
			else
			{
				/* Since the vertex already exists,
				 * its index is taken
				 * from the map */
				v_inds[i] = vit->second;
			}
		}

		/* triangulate this leaf based on its neighbors */
		// TODO
		
		// TODO temporary meshing
		poly.clear();
		for(i = 0; i < quadnode_t::CHILDREN_PER_QUADNODE; i++)
			poly.vertices.push_back(v_inds[i]);
		mesh.add(poly);
	}

	/* recurse */
	for(i = 0; i < quadnode_t::CHILDREN_PER_QUADNODE; i++)
		if(q->children[i] != NULL)
		{
			ret = this->triangulate(mesh, 
					vert3d_ind, q->children[i]);
			if(ret)
				return PROPEGATE_ERROR(-1, ret);
		}

	/* success */
	return 0;
}
		
void region_isostuffer_t::writeobj(std::ostream& os, quadnode_t* q) const
{
	map<corner_t, size_t>::const_iterator vit;
	Vector2d pts2d;
	Vector3d pts3d;
	corner_t corner;
	color_t c;
	size_t i;

	/* check arguments */
	if(q == NULL)
	{
		/* write some comments at the top */
		os << endl
		   << "# M = " 
		   << this->M(0,0) << " " 
		   << this->M(0,1) << " " 
		   << this->M(0,2) << endl
		   << "#     "
		   << this->M(1,0) << " " 
		   << this->M(1,1) << " " 
		   << this->M(1,2) << endl
		   << endl;

		/* write the boundary verts */
		os << "# The boundary vertex corner indices:" << endl;
		for(vit = this->vert2d_ind.begin(); 
				vit != this->vert2d_ind.end();
					vit++)
		{
			os << "# ";
			vit->first.writecsv(os);
			os << endl;
		}
		os << endl;

		/* assign root node */
		q = this->quadtree.get_root();
	}

	/* only write out leaf nodes */
	if(q->isleaf())
	{
		/* iterate over each corner */
		for(i = 0; i < quadnode_t::CHILDREN_PER_QUADNODE; i++)
		{
			/* get position of corners of node */
			pts2d = q->corner_position(i);

			/* check if this is a fixed vertex */
			corner.set(this->quadtree.get_root()->center,
				this->quadtree.get_resolution(),
				pts2d);
			if(this->vert2d_ind.count(corner) > 0)
				c.set(0.0f, 1.0f, 0.0f);
			else
				c.set(1.0f, 0.0f, 0.0f);
		
			/* project quadnode corners back to 3D */
			pts3d = M.transpose() * pts2d;
			this->plane.get_intersection_of(pts3d, pts3d,
						this->nullspace);

			/* write out to file stream */
			os << "v " << pts3d.transpose()
			   <<  " " << c.get_red_int()
			   <<  " " << c.get_green_int()
			   <<  " " << c.get_blue_int()
			   << endl;
		}
	   	os << "f -4 -3 -2 -1" << endl << endl;
	}

	/* recurse */
	for(i = 0; i < quadnode_t::CHILDREN_PER_QUADNODE; i++)
		if(q->children[i] != NULL)
			this->writeobj(os, q->children[i]);
}

/*---------------------------------*/
/* helper function implementations */
/*---------------------------------*/

void region_isostuffer_t::mapping_matrix(octtopo::CUBE_FACE f)
{
	/* store the appropriate matrix */
	switch(f)
	{
		case octtopo::FACE_ZPLUS:
			this->M << 1,0,0,  0,1,0; /* x->x, y->y */
			break;

		case octtopo::FACE_ZMINUS:
			this->M << 0,1,0,  1,0,0; /* x->y, y->x */
			break;

		case octtopo::FACE_YPLUS:
			this->M << 0,0,1,  1,0,0; /* x->y, z->x */
			break;
		
		case octtopo::FACE_YMINUS:
			this->M << 1,0,0,  0,0,1; /* x->x, z->y */
			break;

		case octtopo::FACE_XPLUS:
			this->M << 0,1,0,  0,0,1; /* y->x, z->y */
			break;

		case octtopo::FACE_XMINUS:
			this->M << 0,0,1,  0,1,0; /* y->y, z->x */
			break;
	}

	/* record the normal of this face */
	octtopo::cube_face_normals(f, this->nullspace);
}

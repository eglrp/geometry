#ifndef CARVE_MAP_H
#define CARVE_MAP_H

/**
 * @file carve_map.h
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 *
 * @section DESCRIPTION
 *
 * The carve_map_t class is defined here.  This class is used
 * to compute the result of a carve map, given a position in
 * continuous 3D space.  A carve map is generated by a single
 * range scan, and assigns a value to all of 3D space.  This
 * value is an estimate of the probability that a given point
 * in space is 'interior'.  A value of 0.5 represents no knowledge
 * of the environment, a value of 1.0 indicates certainty that
 * the point is interior, and a value of 0.0 indicates certainty
 * that the point is exterior.
 *
 * This class requires the Eigen framework.
 */

#include <iostream>
#include <Eigen/Dense>

/**
 * This class represents a mapping from R^3 to [0,1], indicating P(interior)
 */
class carve_map_t
{
	/* parameters */
	private:

		/*---------------------*/
		/* input distributions */
		/*---------------------*/

		/* the gaussian distribution of the sensor position */
		Eigen::Vector3d sensor_mean;
		Eigen::Matrix3d sensor_cov;

		/* the gaussian distribution of the scanpoint position */
		Eigen::Vector3d scanpoint_mean;
		Eigen::Matrix3d scanpoint_cov;

		/* the curvature estimates for this scan point */
		double planar_prob; /* value [0,1] indicating planarity */
		double corner_prob; /* value [0,1] indicating right-angle */

		/*-------------------*/
		/* cached parameters */
		/*-------------------*/

		/* unit vector along mean of ray */
		Eigen::Vector3d ray;
		double range; /* mean distance between scanner and point */

		/* each end of the ray is modeled partly with a
		 * plane in line with one of the dominant axes of
		 * the covariance of each gaussian.  These values indicate
		 * the normals of these planes. */
		Eigen::Vector3d sensor_norm;
		double sensor_dot; /* dot(sensor_norm, ray) */
		double sensor_var; /* marginalized variance of sensor */
		double sensor_neg_inv_sqrt_2v; /* 1 / sqrt(2*var) */
		Eigen::Vector3d scanpoint_norm;
		double scanpoint_dot; /* dot(scanpoint_norm, ray) */
		double scanpoint_var; /* marginalized variance of point */
		double scanpoint_neg_inv_sqrt_2v; /* 1 / sqrt(2*var) */

	/* functions */
	public:

		/*--------------*/
		/* constructors */
		/*--------------*/

		/* Since this class contains Eigen structures, we
		 * need to properly align memory */
		EIGEN_MAKE_ALIGNED_OPERATOR_NEW

		/**
		 * Initializes empty map
		 */
		carve_map_t();

		/**
		 * Initializes carve map based on two gaussian distribs.
		 *
		 * @param s_mean  Mean of sensor position
		 * @param s_cov   Covariance of sensor position
		 * @param p_mean  Mean of scanpoint position
		 * @param p_cov   Covariance of scanpoint position
		 */
		carve_map_t(const Eigen::Vector3d& s_mean,
		            const Eigen::Matrix3d& s_cov,
		            const Eigen::Vector3d& p_mean,
		            const Eigen::Matrix3d& p_cov);

		/**
		 * Initializes this carve map based on two gaussians
		 *
		 * Will initialze all stored parameters based on the
		 * gaussian distributions of the sensor positon and
		 * the scanpoint position in 3D space.
		 *
		 * @param s_mean  Mean of sensor position
		 * @param s_cov   Covariance of sensor position
		 * @param p_mean  Mean of scanpoint position
		 * @param p_cov   Covariance of scanpoint position
		 */
		void init(const Eigen::Vector3d& s_mean,
		          const Eigen::Matrix3d& s_cov,
		          const Eigen::Vector3d& p_mean,
		          const Eigen::Matrix3d& p_cov);

		/*-----------*/
		/* accessors */
		/*-----------*/

		/**
		 * Copies sensor mean position into given structure
		 *
		 * Will set the position of the given vector to the
		 * sensor mean position of this carving object.
		 *
		 * @param s   Where to copy the sensor mean position
		 */
		inline void get_sensor_mean(Eigen::Vector3d& s) const
		{ s = this->sensor_mean; };

		/**
		 * Returns pointer to the sensor mean vector
		 */
		const Eigen::Vector3d* get_sensor_mean_ptr() const
		{ return &(this->sensor_mean); };

		/**
		 * Copies sensor covariance into given structure
		 *
		 * Will set the given matrix to the sensor position's
		 * covariance matrix.
		 *
		 * @param C  Where to copy the covariance matrix.
		 */
		inline void get_sensor_cov(Eigen::Matrix3d& C) const
		{ C = this->sensor_cov; };

		/**
		 * Copies scanpoint mean position into given structure
		 *
		 * Will set the position of the given vector to the
		 * scanpoint mean position of this carving object.
		 *
		 * @param p  Where to copy the scanpoint mean position
		 */
		inline void get_scanpoint_mean(Eigen::Vector3d& p) const
		{ p = this->scanpoint_mean; };
	
		/**
		 * Returns pointer to the scanpoint mean vector
		 */
		const Eigen::Vector3d* get_scanpoint_mean_ptr() const
		{ return &(this->scanpoint_mean); };

		/**
		 * Copies scanpoint covariance into given structure
		 *
		 * Will set the given matrix to the scanpoint position's
		 * covariance matrix.
		 *
		 * @param C  Where to copy the covariance matrix.
		 */
		inline void get_scanpoint_cov(Eigen::Matrix3d& C) const
		{ C = this->scanpoint_cov; };

		/**
		 * Yields the variance of the scanpoint position along ray
		 *
		 * Returns the variance of the position of the scanpoint
		 * of this carve map, marginalized along the length
		 * of the ray.
		 *
		 * @return   Returns variance of scanpoint pos along ray
		 */
		inline double get_scanpoint_var() const
		{ return this->scanpoint_var; };

		/**
		 * Returns the mean range between scanpoint and sensor
		 */
		inline double get_range() const
		{ return this->range; };

		/**
		 * Retrieves the planar probability of this scan point
		 */
		inline double get_planar_prob() const
		{ return this->planar_prob; };

		/**
		 * Sets the planar probability of this scan point
		 *
		 * @param p   The value [0,1] to set to
		 */
		inline void set_planar_prob(double p)
		{ this->planar_prob = p; };

		/**
		 * Retrieves the corner probability of this scan point
		 */
		inline double get_corner_prob() const
		{ return this->corner_prob; };

		/**
		 * Sets the corner probability of this scan point
		 *
		 * @param c   The value [0,1] to set to
		 */
		inline void set_corner_prob(double c)
		{ this->corner_prob = c; };

		/*-------------*/
		/* computation */
		/*-------------*/
	
		/**
		 * Computes the value of this carve map at the given loc
		 *
		 * Given a location and a feature size at that location,
		 * will compute the estimate of this carve map for that
		 * location.  The feature size should be a rough distance
		 * estimate of the feature length of the volume being
		 * analyzed.  The result of this computation will be
		 * a probability estimate of whether that volume is
		 * interior.
		 *
		 * 0.0 ............ 0.5 ........... 1.0
		 * exterior       unknown      interior
		 *
		 * @param x      The volume center in 3D space to analyze
		 * @param xsize  The feature length of volume at x
		 *
		 * @return   Returns probability that volume is interior
		 */
		double compute(const Eigen::Vector3d& x,double xsize) const;

		/*-----*/
		/* i/o */
		/*-----*/

		/**
		 * Serializes this object to the given binary stream
		 *
		 * Will export this carve map's parameters to the given
		 * binary output stream.
		 *
		 * @param os  The binary output stream to write to
		 */
		void serialize(std::ostream& os) const;

		/**
		 * Parses serialized information from the given stream
		 *
		 * Will parse the given input stream as a serialized
		 * carve map, and stores the found information in this
		 * object.
		 *
		 * @param is  The binary input stream to read from
		 *
		 * @return    Returns zero on success, non-zero on failure.
		 */
		int parse(std::istream& is);

		/*-----------*/
		/* debugging */
		/*-----------*/

		/**
		 * Prints textual debugging info to the given stream
		 *
		 * @param os   The output stream to write to
		 */
		void print_params(std::ostream& os) const;

		/**
		 * Will export a sampling of this mapping to the outstream
		 *
		 * Will provide a sampling of 3D points near and around
		 * the originating ray of this mapping, and write these
		 * to the ASCII stream.  Each line of the stream will
		 * be one sample point, formatted as:
		 *
		 * <x> <y> <z> <f>
		 *
		 * Where <x,y,z> is a 3D position, and <f> is the value
		 * of this mapping at that position.  The first line will
		 * be the sensor mean position and the second line will
		 * be the scanpoint mean position.
		 *
		 * @param os   The output stream to write to
		 */
		void print_sampling(std::ostream& os) const;

		/**
		 * Will export meshes of gaussian models to OBJ file
		 *
		 * Will export a mesh representing the basic shape
		 * of the probability distribution of this point/sensor
		 * pair to a wavefront OBJ file stream.
		 *
		 * @param out   The output stream to write to
		 */
		void writeobj(std::ostream& out) const;

		/**
		 * Will export the mean scanpoint position to XYZ file
		 *
		 * Will export the mean position of the scanpoint
		 * distribution as described by this carvemap, in .xyz
		 * format, to the specified stream.  This will be colored
		 * using the planarity and corner features of this point.
		 *
		 * @param out   The output stream to write to
		 */
		void writexyz(std::ostream& out) const;

	/* helper functions */
	private:

		/**
		 * Finds principal component that best aligns with input
		 *
		 * Given an input vector and an input matrix, will find
		 * the eigenvector of the matrix that is the closest
		 * aligned with the input vector.  This vector will be
		 * an output, with an orientation to be the same as the
		 * input vector (so their dot-product is positive).
		 *
		 * @param eig   Where to store the output vector
		 * @param in    The input vector to analyze
		 * @param M     The input matrix to analyze
		 *
		 * @return      Returns dot(eig, in)
		 */
		static double find_aligned_eig(Eigen::Vector3d& eig,
		                               const Eigen::Vector3d& in,
		                               const Eigen::Matrix3d& M);
};

#endif

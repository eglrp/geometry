#include "octtopo.h"
#include "octree.h"
#include "octnode.h"
#include <Eigen/Dense>
#include <algorithm>
#include <utility>
#include <fstream>
#include <string>
#include <vector>
#include <map>

/**
 * @file octtopo.cpp
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 * @brief  The octtopo_t class is used for computing octree topology
 *
 * @section DESCRIPTION
 *
 * This file contains the octtopo_t class, which is used to provide
 * additional representations of octree and octnode topology.  Its
 * main purpose is to allow for relative neighbor linkages between
 * adjacent nodes.
 *
 * While this class is not part of the octree structure directly, it
 * can be provided with an octree to be initialized, and used to augment
 * an existing tree structure information.
 */

using namespace std;
using namespace Eigen;
using namespace octtopo;

/* octneighbors_t function implementations */

void octneighbors_t::clear()
{ 
	size_t i;
	for(i = 0; i < NUM_FACES_PER_CUBE; i++)
		this->neighs[i].clear();
}

void octneighbors_t::add_all(const std::vector<octnode_t*>& ns, CUBE_FACE f)
{
	size_t i, n;
	n = ns.size();
	for(i = 0; i < n; i++)
		this->add(ns[i], f);
}

void octneighbors_t::get_singletons(octnode_t* ns[NUM_FACES_PER_CUBE]) const
{
	size_t i;
	for(i = 0; i < NUM_FACES_PER_CUBE; i++)
		ns[i] = (this->neighs[i].size() == 1)
				? this->neighs[i][0] : NULL;
}
			
octneighbors_t& octneighbors_t::operator = (const octneighbors_t& other)
{
	size_t i;

	/* copy each value */
	for(i = 0; i < NUM_FACES_PER_CUBE; i++)
	{
		/* destroy existing */
		this->neighs[i].clear();
		this->neighs[i].insert(this->neighs[i].begin(), 
			other.neighs[i].begin(), other.neighs[i].end());
	}

	/* return changed object */
	return (*this);
}

/* octtopo_t function implementations */

void octtopo_t::init(const octree_t& tree)
{
	/* the root node of this tree can't have any neighbors, since
	 * there are no other nodes on that level */
	this->neighs.clear();
	this->neighs.insert(pair<octnode_t*, octneighbors_t>(
			tree.get_root(), octneighbors_t()));

	/* recursively populate the map with the subnodes of this tree */
	this->init_children(tree.get_root());

	/* now that all nodes have been mapped, clean up */
	//TODO this->remove_nonleafs();

	// TODO debugging
	cout << "[octtopo_t::init]\tverification results: " 
	     << this->verify() << endl;
}
			
int octtopo_t::writeobj(const string& filename) const
{
	map<octnode_t*, octneighbors_t>::const_iterator it;
	vector<octnode_t*> ns;
	vector<octnode_t*>::iterator nit;
	Vector3d p;
	ofstream outfile;
	size_t fi;

	/* open file for writing */ 
	outfile.open(filename.c_str());
	if(!(outfile.is_open()))
		return -1;

	/* prepare file */
	outfile << "# This file auto-generated by Eric Turner's"
	        << "# geometry code for UC Berkeley's VIP Lab."
	        << endl << endl;

	/* iterate through the nodes */
	for(it = this->neighs.begin(); it != this->neighs.end(); it++)
	{
		/* check if leaf and interior */
		if(it->first->data == NULL)
			continue;
		if(!(it->first->data->is_interior()))
			continue;

		/* iterate over faces, looking for exterior neighbors */
		for(fi = 0; fi < NUM_FACES_PER_CUBE; fi++)
		{
			/* get nodes neighboring on this face */
			ns.clear();
			it->second.get(all_cube_faces[fi], ns);

			/* check for external nodes */
			for(nit = ns.begin(); nit != ns.end(); nit++)
			{
				/* ignore if interior or non-leaf */
				if((*nit)->data == NULL)
					continue;
				if((*nit)->data->is_interior())
					continue;

				/* neighbor is exterior, so export face */
				this->writeobjface(outfile, it->first,
				                   all_cube_faces[fi]);
			}
			if(ns.empty())
				this->writeobjface(outfile, it->first,
				                   all_cube_faces[fi]);
		}
	}

	/* success */
	outfile.close();
	return 0;
}
			
void octtopo_t::writeobjface(ostream& os, octnode_t* n, CUBE_FACE f) const
{
	Vector3d c;
	double hw;

	/* check for null argument */
	if(n == NULL)
		return; /* don't write anything */

	/* get node properties */
	c = n->center;
	hw = n->halfwidth;

	/* switch based on face direction */
	switch(f)
	{
		case FACE_XMINUS:
			/* write face */
			c(0) -= hw;
			os << "v " <<  c(0) 
			    << " " << (c(1)-hw)
			    << " " << (c(2)-hw) 
			    << "128 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)-hw)
			    << " " << (c(2)+hw)
			    << "128 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)+hw)
			    << " " << (c(2)+hw)
			    << "128 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)+hw)
			    << " " << (c(2)-hw)
			    << "128 0 0" << endl
			   << "f -4 -3 -2 -1" << endl;
			break;
		case FACE_XPLUS:
			/* write face */
			c(0) += hw;
			os << "v " <<  c(0) 
			    << " " << (c(1)-hw)
			    << " " << (c(2)-hw) 
			    << "255 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)-hw)
			    << " " << (c(2)+hw)
			    << "255 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)+hw)
			    << " " << (c(2)+hw)
			    << "255 0 0" << endl
			   << "v " <<  c(0)
			    << " " << (c(1)+hw)
			    << " " << (c(2)-hw)
			    << "255 0 0" << endl
			   << "f -1 -2 -3 -4" << endl;
			break;
		case FACE_YMINUS:
			/* write face */
			c(1) -= hw;
			os << "v " << (c(0)-hw)
			    << " " <<  c(1)
			    << " " << (c(2)-hw) 
			    << "0 128 0" << endl
			   << "v " << (c(0)-hw)
			    << " " <<  c(1)
			    << " " << (c(2)+hw)
			    << "0 128 0" << endl
			   << "v " << (c(0)+hw)
			    << " " <<  c(1)
			    << " " << (c(2)+hw)
			    << "0 128 0" << endl
			   << "v " << (c(0)+hw)
			    << " " <<  c(1)
			    << " " << (c(2)-hw)
			    << "0 128 0" << endl
			   << "f -4 -3 -2 -1" << endl;
			break;
		case FACE_YPLUS:
			/* write face */
			c(1) += hw;
			os << "v " << (c(0)-hw)
			    << " " <<  c(1)
			    << " " << (c(2)-hw) 
			    << "0 255 0" << endl
			   << "v " << (c(0)-hw)
			    << " " <<  c(1)
			    << " " << (c(2)+hw)
			    << "0 255 0" << endl
			   << "v " << (c(0)+hw)
			    << " " <<  c(1)
			    << " " << (c(2)+hw)
			    << "0 255 0" << endl
			   << "v " << (c(0)+hw)
			    << " " <<  c(1)
			    << " " << (c(2)-hw)
			    << "0 255 0" << endl
			   << "f -1 -2 -3 -4" << endl;
			break;
		case FACE_ZMINUS:
			/* write face */
			c(2) -= hw;
			os << "v " << (c(0)-hw)
			    << " " << (c(1)-hw)
			    << " " <<  c(2) 
			    << "0 0 128" << endl
			   << "v " << (c(0)+hw)
			    << " " << (c(1)-hw)
			    << " " <<  c(2)
			    << "0 0 128" << endl
			   << "v " << (c(0)+hw)
			    << " " << (c(1)+hw)
			    << " " <<  c(2)
			    << "0 0 128" << endl
			   << "v " << (c(0)-hw)
			    << " " << (c(1)+hw)
			    << " " <<  c(2)
			    << "0 0 128" << endl
			   << "f -4 -3 -2 -1" << endl;
			break;
		case FACE_ZPLUS:
			/* write face */
			c(0) += hw;
			os << "v " << (c(0)-hw)
			    << " " << (c(1)-hw)
			    << " " <<  c(2) 
			    << "0 0 255" << endl
			   << "v " << (c(0)+hw)
			    << " " << (c(1)-hw)
			    << " " <<  c(2)
			    << "0 0 255" << endl
			   << "v " << (c(0)+hw)
			    << " " << (c(1)+hw)
			    << " " <<  c(2)
			    << "0 0 255" << endl
			   << "v " << (c(0)-hw)
			    << " " << (c(1)+hw)
			    << " " <<  c(2)
			    << "0 0 255" << endl
			   << "f -1 -2 -3 -4" << endl;
			break;
	}
}

void octtopo_t::init_children(octnode_t* node)
{
	octneighbors_t ns[CHILDREN_PER_NODE];
	octnode_t* uncles[NUM_FACES_PER_CUBE];
	vector<octnode_t*> all_uncs;
	unsigned int i;

	/* get all existing neighbors of current node */
	this->neighs[node].get_singletons(uncles);

	/* each child of this node must be added as a special case,
	 * based on the relative position of the child with respect to
	 * the other nodes in play (which includes children of the current
	 * node's neighbors).
	 *
	 * The ordering of octnodes can be found here 
	 * (taken from octnode.h):
	 * 
	 * 		y
	 *              ^
	 *       1      |      0
	 *              |
	 * -------------+-------------> x	(top, z+)
	 *              |
	 *       2      |      3
	 *              |
	 *
	 * 		y
	 *              ^
	 *       5      |      4
	 *              |
	 * -------------+-------------> x	(bottom, z-)
	 *              |
	 *       6      |      7
	 *              |
	 */

	/* internal linkages of this node's children */

	/* top level */
	ns[0].add(node->children[1], FACE_XMINUS);
	ns[1].add(node->children[0], FACE_XPLUS);
	ns[1].add(node->children[2], FACE_YMINUS);
	ns[2].add(node->children[1], FACE_YPLUS);
	ns[2].add(node->children[3], FACE_XPLUS);
	ns[3].add(node->children[2], FACE_XMINUS);
	ns[3].add(node->children[0], FACE_YPLUS);
	ns[0].add(node->children[3], FACE_YMINUS);
	
	/* bottom level */
	ns[4].add(node->children[5], FACE_XMINUS);
	ns[5].add(node->children[4], FACE_XPLUS);
	ns[5].add(node->children[6], FACE_YMINUS);
	ns[6].add(node->children[5], FACE_YPLUS);
	ns[6].add(node->children[7], FACE_XPLUS);
	ns[7].add(node->children[6], FACE_XMINUS);
	ns[7].add(node->children[4], FACE_YPLUS);
	ns[4].add(node->children[7], FACE_YMINUS);

	/* up-down */
	ns[0].add(node->children[4], FACE_ZMINUS);
	ns[1].add(node->children[5], FACE_ZMINUS);
	ns[2].add(node->children[6], FACE_ZMINUS);
	ns[3].add(node->children[7], FACE_ZMINUS);
	ns[4].add(node->children[0], FACE_ZPLUS);
	ns[5].add(node->children[1], FACE_ZPLUS);
	ns[6].add(node->children[2], FACE_ZPLUS);
	ns[7].add(node->children[3], FACE_ZPLUS);

	/* external linkages to other nodes on current level */
	
	/* cousins x-plus */
	if(uncles[FACE_XPLUS]) 
	{
		ns[0].add(uncles[FACE_XPLUS]->children[1], FACE_XPLUS);
		ns[3].add(uncles[FACE_XPLUS]->children[2], FACE_XPLUS);
		ns[4].add(uncles[FACE_XPLUS]->children[5], FACE_XPLUS);
		ns[7].add(uncles[FACE_XPLUS]->children[6], FACE_XPLUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_XPLUS, all_uncs);
		ns[0].add_all(all_uncs, FACE_XPLUS);
		ns[3].add_all(all_uncs, FACE_XPLUS);
		ns[4].add_all(all_uncs, FACE_XPLUS);
		ns[7].add_all(all_uncs, FACE_XPLUS);
	}

	/* cousins x-minus */
	if(uncles[FACE_XMINUS]) 
	{
		ns[1].add(uncles[FACE_XMINUS]->children[0], FACE_XMINUS);
		ns[2].add(uncles[FACE_XMINUS]->children[3], FACE_XMINUS);
		ns[5].add(uncles[FACE_XMINUS]->children[4], FACE_XMINUS);
		ns[6].add(uncles[FACE_XMINUS]->children[7], FACE_XMINUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_XMINUS, all_uncs);
		ns[1].add_all(all_uncs, FACE_XMINUS);
		ns[2].add_all(all_uncs, FACE_XMINUS);
		ns[5].add_all(all_uncs, FACE_XMINUS);
		ns[6].add_all(all_uncs, FACE_XMINUS);
	}
	
	/* cousins y-plus */
	if(uncles[FACE_YPLUS]) 
	{
		ns[0].add(uncles[FACE_YPLUS]->children[3], FACE_YPLUS);
		ns[1].add(uncles[FACE_YPLUS]->children[2], FACE_YPLUS);
		ns[4].add(uncles[FACE_YPLUS]->children[7], FACE_YPLUS);
		ns[5].add(uncles[FACE_YPLUS]->children[6], FACE_YPLUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_YPLUS, all_uncs);
		ns[0].add_all(all_uncs, FACE_YPLUS);
		ns[1].add_all(all_uncs, FACE_YPLUS);
		ns[4].add_all(all_uncs, FACE_YPLUS);
		ns[5].add_all(all_uncs, FACE_YPLUS);
	}
	
	/* cousins y-minus */
	if(uncles[FACE_YMINUS]) 
	{
		ns[3].add(uncles[FACE_YMINUS]->children[0], FACE_YMINUS);
		ns[2].add(uncles[FACE_YMINUS]->children[1], FACE_YMINUS);
		ns[7].add(uncles[FACE_YMINUS]->children[4], FACE_YMINUS);
		ns[6].add(uncles[FACE_YMINUS]->children[5], FACE_YMINUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_YMINUS, all_uncs);
		ns[3].add_all(all_uncs, FACE_YMINUS);
		ns[2].add_all(all_uncs, FACE_YMINUS);
		ns[7].add_all(all_uncs, FACE_YMINUS);
		ns[6].add_all(all_uncs, FACE_YMINUS);
	}
	
	/* cousins z-plus */
	if(uncles[FACE_ZPLUS]) 
	{
		ns[0].add(uncles[FACE_ZPLUS]->children[4], FACE_ZPLUS);
		ns[1].add(uncles[FACE_ZPLUS]->children[5], FACE_ZPLUS);
		ns[2].add(uncles[FACE_ZPLUS]->children[6], FACE_ZPLUS);
		ns[3].add(uncles[FACE_ZPLUS]->children[7], FACE_ZPLUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_ZPLUS, all_uncs);
		ns[0].add_all(all_uncs, FACE_ZPLUS);
		ns[1].add_all(all_uncs, FACE_ZPLUS);
		ns[2].add_all(all_uncs, FACE_ZPLUS);
		ns[3].add_all(all_uncs, FACE_ZPLUS);
	}
	
	/* cousins z-minus */
	if(uncles[FACE_ZMINUS]) 
	{
		ns[4].add(uncles[FACE_ZMINUS]->children[0], FACE_ZMINUS);
		ns[5].add(uncles[FACE_ZMINUS]->children[1], FACE_ZMINUS);
		ns[6].add(uncles[FACE_ZMINUS]->children[2], FACE_ZMINUS);
		ns[7].add(uncles[FACE_ZMINUS]->children[3], FACE_ZMINUS);
	}
	else
	{
		/* if got here, this node may be deeper than neighboring
		 * nodes, so add uncles as cousins */
		all_uncs.clear();
		this->neighs[node].get(FACE_ZMINUS, all_uncs);
		ns[4].add_all(all_uncs, FACE_ZMINUS);
		ns[5].add_all(all_uncs, FACE_ZMINUS);
		ns[6].add_all(all_uncs, FACE_ZMINUS);
		ns[7].add_all(all_uncs, FACE_ZMINUS);
	}

	/* For each child, check if it exists and pair it appropriately
	 * with the populated neighbor object
	 */
	for(i = 0; i < CHILDREN_PER_NODE; i++)
	{
		/* check if exists */
		if(node->children[i] == NULL)
			continue; /* move on to next child */

		/* aggressively add this child into neighbor map */
		this->neighs[node->children[i]] = ns[i];
	
		/* recurse */
		this->init_children(node->children[i]);
	}
}
			
void octtopo_t::remove_nonleafs()
{
	map<octnode_t*, octneighbors_t>::iterator it;

	/* remove the non-leaf nodes in the map */
	for(it = this->neighs.begin(); it != this->neighs.end(); )
	{
		if(!(it->first->isleaf()))
			this->neighs.erase(it++);
		else
			it++;
	}
}
			
int octtopo_t::verify() const
{
	map<octnode_t*, octneighbors_t>::const_iterator it, opp_it;
	vector<octnode_t*> ns, ns_opp;
	vector<octnode_t*>::iterator nit;
	CUBE_FACE opp;
	size_t i;
	int ret;

	if(this->neighs.empty())
	{
		/* not an error, but make a note */
		cerr << "[octtopo_t::verify]\tWARNING: empty map" << endl;
	}

	/* iterate over each node in the map */
	for(it = this->neighs.begin(); it != this->neighs.end(); it++)
	{
		/* check for null nodes */
		if(it->first == NULL)
		{
			/* notify user of error */
			ret = -1;
			cerr << "[octtopo_t::verify]\tERROR " << ret << ": "
			     << "Encountered null node in map!" << endl;
			return ret;
		}

		/* iterate over faces of current node */
		for(i = 0; i < NUM_FACES_PER_CUBE; i++)
		{
			/* get neighbors on this face */
			ns.clear(); it->second.get(all_cube_faces[i], ns);

			/* check for non-singletons */
			if(ns.size() > 1 && !(it->first->isleaf()))
			{
				/* notify user of error */
				ret = -2;
				cerr << "[octtopo_t::verify]\t"
				     << "ERROR " << ret << ": "
				     << "Encountered " << ns.size()
				     << "neighbors on face "
				     << all_cube_faces[i]
				     << " of node " << it->first << endl;
				return ret;
			}
			
			/* iterate over neighbors on this face */
			opp = get_opposing_face(all_cube_faces[i]);
			for(nit = ns.begin(); nit != ns.end(); nit++)
			{
				/* make sure not null */
				if(*nit == NULL)
				{
					/* notify user of error */
					ret = -3;
					cerr << "[octtopo_t::verify]\t"
					     << "ERROR " << ret << ": "
					     << (it->first) << " has null "
					     << "neighbor on "
					     << all_cube_faces[i]
					     << endl;
					return ret;
				}

				/* make sure we have no autoloops */
				if(*nit == it->first)
				{
					/* notify user of error */
					ret = -4;
					cerr << "[octtopo_t::verify]\t"
					     << "ERROR " << ret << ": "
					     << (*nit) << " neighbors "
					     << "itself on face "
					     << all_cube_faces[i]
					     << endl;
					return ret;
				}

				/* get neighbor's neighbors, and check
				 * if current node is among them */
				opp_it = this->neighs.find(*nit);
				if(opp_it == this->neighs.end())
				{
					/* notify user of error */
					ret = -5;
					cerr << "[octtopo_t::verify]\t"
					     << "ERROR " << ret << ": "
					     << (*nit) << " not in map "
					     << "even though "
					     << it->first << " thinks it "
					     << "neighbors on "
					     << all_cube_faces[i]
					     << endl;
					return ret;
				}

				ns_opp.clear(); opp_it->second.get(opp,
								ns_opp);
				if(find(ns_opp.begin(), ns_opp.end(), 
						it->first) == ns_opp.end())
				{
					/* notify user of error */
					ret = -6;
					cerr << "[octtopo_t::verify]\t"
					     << "ERROR " << ret << ": "
					     << it->first << " claims "
					     << "neighbor on "
					     << all_cube_faces[i]
					     << " is " << (*nit) << " but "
					     << " this node's neighbors "
					     << "on " << opp << " does not "
					     << "show " << it->first
					     << endl;
					return ret;
				}
			}
		}
	}

	/* success */
	return 0;
}

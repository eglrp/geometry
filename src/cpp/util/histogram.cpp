#include "histogram.h"
#include <map>
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <math.h>
#include <stdlib.h>

/**
 * @file    histogram.cpp
 * @author  Eric Turner <elturner@eecs.berkeley.edu>
 * @brief   Performs a 1D histogram from input data
 *
 * @section DESCRIPTION
 *
 * This file defines a class that will construct a histogram of
 * scalar values at a specified bin-size / resolution.
 */

using namespace std;

/*--------------------------*/
/* function implementations */
/*--------------------------*/

histogram_t::histogram_t()
{
	this->clear();
}

histogram_t::~histogram_t()
{
	this->clear();
}

void histogram_t::clear()
{
	this->hist.clear();
	this->res = 1.0; /* default resolution */
}

void histogram_t::set_resolution(double r)
{
	/* clear data */
	this->clear();
	
	/* store the specified resolution */
	this->res = fabs(r);

	/* verify that resolution is not zero, since
	 * we will need to divide by it */
	if(this->res == 0)
		this->res = 1.0; /* arbitrary default resolution */
}

void histogram_t::insert(double v, double w)
{
	int vi;

	/* discretize the input */
	vi = this->get_index(v);

	/* insert into map */
	this->hist[vi] += w;
}

void histogram_t::insert(const histogram_t& other)
{
	map<int, double>::const_iterator it;
	int vi;

	/* iterate through elements of other histogram */
	for(it = other.hist.begin(); it != other.hist.end(); it++)
	{
		/* get index of other's element into this histogram */
		vi = this->get_index(other.bin_center(it->first));

		/* update counts */
		this->hist[vi] += it->second;
	}
}

double histogram_t::max() const
{
	map<int, double>::const_iterator it;
	int max_i;
	double max_c

	/* iterate through elements */
	max_c = 0;
	max_i = 0;
	for(it = this->hist.begin(); it != this->hist.end(); it++)
		if(it->second > max_c)
		{
			/* update max */
			max_i = it->first;
			max_c = it->second;
		}

	/* return max */
	return this->bin_center(max_i);
}

void histogram_t::find_peaks(vector<double>& peaks, vector<double>& counts,
						double min_buffer) const
{
	map<int, double>::const_iterator it;
	vector<pair<int, double> > local_max;
	bool is_local_max;
	int i, bi, n;
	double x2, x, stddev, mean;

	/* convert the minimum buffer space specified into units of
	 * histogram bins */
	bi = (int) ceil(min_buffer / this->res);
	if(bi <= 0)
		bi = 1;

	/* compute the std-dev of the histogram */
	x2 = x = stddev = 0;
	for(it = this->hist.begin(); it != this->hist.end(); it++)
	{
		x += it->second;
		x2 += (it->second * it->second);
	}
	stddev = sqrt( (x2 - x) / (this->hist.size()) );
	mean = x / (this->hist.size());

	/* find local maxima that are maxima within neighborhoods of bi */
	for(it = this->hist.begin(); it != this->hist.end(); it++)
	{
		/* check if this value is above one std. dev. of the mean */
		if(it->second < mean + stddev)
			continue;
		
		/* initially assume it is local max */
		is_local_max = true;

		/* compare current bin's count to neighborhood */
		for(i = -bi; i <= bi; i++)
		{
			/* ignore identity case */
			if(i == 0)
				continue; 

			/* compare neighbor to current bin */
			if(this->hist[it->first + i] > it->second)
			{
				is_local_max = false;
				break;
			}
		}

		/* check if local max */
		if(is_local_max)
			local_max.push_back(*it);
	}

	/* export final set */
	n = local_max.size();
	peaks.reserve(n);
	counts.reserve(n);
	for(i = 0; i < n; i++)
	{
		peaks.push_back(this->bin_center(local_max[i].first));
		counts.push_back(local_max[i].second);
	}
}

int histogram_t::export_to_matlab(ostream& outfile, bool vertical) const
{
	map<int, int>::iterator it;

	/* check file for writing */
	if(!(outfile.is_open()))
		return -1;

	/* put comment at top of script */
	outfile << ((char) 0x25) << " "
	        << "This script was auto-generated by" << endl
	        << ((char) 0x25) << " "
		<< "Eric Turner's C++ histogram code." << endl
		<< endl
	        << ((char) 0x25) << " "
		<< "r represents the resolution of the bins" << endl
		<< "r = " << this->res << ";" << endl << endl
	        << ((char) 0x25) << " "
		<< "N represents bin counts" << endl
		<< "N = [";

	/* write out bin counts */
	for(it = this->hist.begin(); it != this->hist.end(); it++)
		outfile << " " << it->second;
	
	/* close array */
	outfile << " ];" << endl << endl;

	/* start next variable */
	outfile << ((char) 0x25) << " "
	        << "X represents the bin centers" << endl
	        << "X = [";

	/* write out bin centers */
	for(it = this->hist.begin(); it != this->hist.end(); it++)
		outfile << " " << this->bin_center(it->first);
	
	/* finish array */
	outfile << " ];" << endl << endl;

	/* plot the histogram with peaks highlighted*/
	outfile << ((char) 0x25) << " plot the histogram:" << endl
	        << "figure(1);" << endl
		<< "hold all;" << endl;

	if(vertical)
		outfile << "plot(N, X, '-o";
	else
		outfile << "plot(X, N, '-o";
	
	/* plot with random color */
	switch(rand() % 5)
	{
		case 0:
			outfile << "b";
			break;
		case 1:
			outfile << "g";
			break;
		case 2:
			outfile << "c";
			break;
		case 3:
			outfile << "m";
			break;
		case 4:
			outfile << "k";
			break;
	}

	/* finish plotting */
	outfile << "');" << endl
		<< endl;

	/* clean up */
	return 0;
}

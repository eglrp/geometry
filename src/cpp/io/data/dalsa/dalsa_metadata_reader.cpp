#include "dalsa_metadata_reader.h"
#include <fstream>
#include <istream>
#include <sstream>
#include <string>
#include <string.h>
#include <util/error_codes.h>

/**
 * @file dalsa_metadata_reader.cpp
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 *
 * @section DESCRIPTION
 *
 * This file contains definitions for classes used to read
 * and parse the output metadata files generated by the teledyne
 * dalsa cameras.  These files include the relative paths to
 * collected imagery, as well as the meta-information for each image,
 * such as timestamp and camera settings.
 */

using namespace std;

/* The following constants are used to parse the DALSA files */

#define MAGIC_NUMBER "dalsa"

/* function implementations for dalsa_frame_t */
dalsa_frame_t::dalsa_frame_t()
{
	/* set default values */
	this->image_path = "";
	this->image_number = -1;
	this->cam_time = 0;
	this->exposure = -1;
	this->gain = -1;
}

dalsa_frame_t::~dalsa_frame_t()
{
	/* no resources explicitly allocated */
}

int dalsa_frame_t::parse(std::istream& is)
{
	stringstream ss;
	string line;
	size_t p;

	/* check that stream is still valid */
	if(is.fail())
		return -1;

	/* parse the next line from file */
	getline(is, line);
	if(line.empty())
	{
		this->image_number = -1;
		return 0;
	}

	/* parse values from line */
	ss.str(line);
	ss >> this->image_path;
	ss >> this->image_number;
	ss >> this->cam_time;
	ss >> this->exposure;
	ss >> this->gain;

	/* verify file separators are good for all platforms */
	while(true)
	{
		/* check if any instance of backslash is found */
		p = this->image_path.find('\\');
		if(p == string::npos)
			break;

		/* replace it */
		this->image_path[p] = '/';
	} 

	/* check that stream is good */
	if(is.fail())
		return -3;
	
	/* success */
	return 0;
}

/* function implementations for dalsa_reader_t */

dalsa_reader_t::dalsa_reader_t()
{
	/* default values already set */
}

dalsa_reader_t::~dalsa_reader_t()
{
	/* close the file if necessary */
	this->close();
}

/* helper function:
 *
 * Removes all occurances of carriage returns
 * from the string.
 */
void remove_all_cr(string& m)
{
	size_t pos;
	
	/* remove all \r that are found */
	while(true)
	{
		/* check if there are any carriage returns
		 * on this line */
		pos = m.find('\r');
		if(pos == string::npos)
			break;

		/* remove them if present */
		m.erase(pos);
	}
}

int dalsa_reader_t::open(const std::string& filename)
{
	string m;

	/* close any open files */
	this->close();

	/* open the file */
	this->infile.open(filename.c_str());
	if(!(this->infile.is_open()))
		return -1;

	/* read the header */
	
	/* retrieve magic number */
	getline(this->infile, m);
	remove_all_cr(m);

	/* check validity of magic number */
	if(strcmp(m.c_str(), MAGIC_NUMBER))
	{
		/* this is not a dalsa metadata file */
		this->close();
		return -2;
	}

	/* read camera hardware data */
	getline(this->infile, this->camera_name);
	remove_all_cr(this->camera_name);
	getline(this->infile, this->serial_num);
	remove_all_cr(this->serial_num);
	getline(this->infile, this->camera_model);
	remove_all_cr(this->camera_model);
	getline(this->infile, this->image_directory);
	remove_all_cr(this->image_directory);

	/* the header should end with an extra newline */
	getline(this->infile, m);
	remove_all_cr(m);
	if(m.size() > 0)
	{
		this->close();
		return -3;
	}

	/* success */
	return 0;
}

int dalsa_reader_t::next(dalsa_frame_t& frame)
{
	int ret;

	/* parse the next frame from the file */
	ret = frame.parse(this->infile);
	if(ret)
		return PROPEGATE_ERROR(-1, ret);

	/* success */
	return 0;
}

bool dalsa_reader_t::eof() const
{
	/* check if at end of file */
	if(this->infile.is_open())
		return this->infile.eof();
	return true;
}

void dalsa_reader_t::close()
{
	/* close the file if it is open */
	if(this->infile.is_open())
		this->infile.close();

	/* no other resources need freeing */
}

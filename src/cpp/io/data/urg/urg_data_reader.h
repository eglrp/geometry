#ifndef URG_DATA_READER_H
#define URG_DATA_READER_H

/**
 * @file urg_data_reader.h
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 *
 * @section DESCRIPTION
 *
 * This file contains definitions for classes used to read and
 * parse the output data files generated by running the data
 * acquisition code with laser scanners.  The Hakuyo URG laser
 * scanners generate a binary data file to be parsed.
 */

#include <fstream>
#include <istream>
#include <string>
#include <vector>

/* the following classes are defined in this file */
class urg_frame_t;
class urg_reader_t;

/**
 * This class defines one scan line from a Hakuyo URG data file
 */
class urg_frame_t
{
	/* parameters */
	public:

		/* The following indicates the number of points
		 * in a scan frame */
		size_t num_points;

		/* The following array represents the list of
		 * of range values (in units of millimeters) */
		unsigned int* range_values;

		/* Optional intensity values, if available, for
		 * each range value. */
		unsigned int* intensity_values;

		/* The laser-specific timestamp for this scan line,
		 * in milliseconds */
		unsigned int timestamp;

		/* The index of this scan frame */
		unsigned int index;

	/* functions */
	public:

		/* constructors */

		/**
		 * Initializes empty scan frame
		 */
		urg_frame_t();

		/**
		 * Frees all memory and resources
		 */
		~urg_frame_t();

		/* initialization */

		/**
		 * Will parse the next scan block out of a binary stream
		 *
		 * The stream is assumed to be a urg data file, positioned
		 * at the start of a scan block.  The scan block will be
		 * parsed based to populate this struct.
		 *
		 * @param is           The binary stream to read and parse
		 * @param capture_mode True iff intensity values present
		 * @param np           Number of points in a scan
		 *
		 * @return    Returns zero on success, non-zero on failure
		 */
		int parse(std::istream& is, bool capture_mode,
		          unsigned int np);
};

/**
 * This defines the urg_reader_t class to parse a binary laser data file
 */ 
class urg_reader_t
{
	/* parameters */
	private:

		/* the binary file to parse */
		std::ifstream infile;

		/* the number of frames read so far from the file */
		unsigned int next_index;

		/* the version numbers of the file */
		char major_version;
		char minor_version;

		/* scanner hardware information */
		std::string hardware_model;
		std::string serial_num;

		/* metadata about the capture */
		bool capture_mode; /* true iff intensity values collected */
		unsigned int num_scans; /* number of scans captured */
		int points_per_scan; /* number of ranges in one scan */
		int max_range; /* maximum valid range, in millimeters */
		int min_range; /* minimum valid range, in millimeters */

		/* mapping between scan point index and angle in
		 * scanner coordinate frame. This array is length
		 * points_per_scan.  Each angle is in radians. */
		float* angle_map;

		/* the following vector stores stream positions, allowing
		 * for random access of frames in the file */
		std::vector<std::streampos> frame_locs;

	/* functions */
	public:

		/* constructors */

		/**
		 * Constructs empty class
		 */
		urg_reader_t();

		/**
		 * Frees all allocated memory and resources
		 */
		~urg_reader_t();

		/**
		 * Open file for parsing. Verifies file correctly formatted.
		 *
		 * Will open the selected file, and read the header of
		 * this file.  Will only return success if the file
		 * is verified to be a laser binary data file.  After
		 * this is called, will be ready to read scan frames from
		 * file.
		 *
		 * @param filename The path the laser binary data file
		 *
		 * @return     Returns zero on success, non-zero on failure
		 */
		int open(const std::string& filename);

		/**
		 * Parses the next frame from the file
		 *
		 * Will read the next frame from the file and populate
		 * the specified frame struct with its information.
		 *
		 * @param frame The struct to populate with the next frame
		 *
		 * @return     Returns zero on success, non-zero on failure
		 */
		int next(urg_frame_t& frame);

		/**
		 * Parses the frame at the specified index in file
		 *
		 * Will read the frame at the specified index from the
		 * file and store the result in the specified struct.
		 * After calling this function with argument i, calling
		 * the next() function will give frame i+1.
		 *
		 * @param i      The index of the frame of interest
		 * @param frame  Where to store the i'th frame
		 *
		 * @return     Returns zero on success, non-zero on failure
		 */
		int get(unsigned int i, urg_frame_t& frame);

		/**
		 * Retrieves all timestamps of remaining frames.
		 *
		 * Calling this function after opening the file
		 * will give the timestamps for all frames in this
		 * file.  After this function call, this file will
		 * be at eof.
		 *
		 * If one or more frames have been read, then calling
		 * this function will return the timestamps for the
		 * remaining frames.
		 *
		 * @param times   Where to store the timestamps
		 *                (units: milliseconds)
		 *
		 * @return  Returns zero on success, non-zero on failure.
		 */
		int parse_timestamps(std::vector<double>& times);
		
		/**
		 * Returns true iff end of file reached.
		 *
		 * Will pass the eof flag from the file stream as
		 * the return value of this function.
		 *
		 * @return     Returns true iff end-of-file reached
		 */
		bool eof() const;

		/**
		 * Closes the stream and frees resources
		 *
		 * Will close any open file streams and free allocated
		 * arrays in memory.
		 */
		void close();

		/* access functions */
		inline int pointsPerScan() const {
			return this->points_per_scan;
		};
		inline float * angleMap() const {
			return this->angle_map;
		};
		inline unsigned int numScans() const {
			return this->num_scans;
		};
};

#endif

#ifndef WIFI_DATA_READER_H
#define WIFI_DATA_READER_H

/**
 * @file wifi_data_reader.h
 * @author Eric Turner <elturner@eecs.berkeley.edu>
 *
 * @section DESCRIPTION
 *
 * This file contains definitions for classes used to read and
 * parse the output data files generated by running the data
 * acquisition code with wifi.  The WIFI
 * generates a binary data file to be parsed.
 */

#include <fstream>
#include <istream>
#include <ostream>
#include <string>

/* the following are used in formating received data frames */
#define BSSID_SIZE 3 /* number of elements in bssid array */

/* the following classes are defined in this file */
class wifi_frame_t;
class wifi_reader_t;

/**
 * This classes defines one scan line from a WIFI data file
 */
class wifi_frame_t
{
	/* parameters */
	public:

		/* The index of this scan frame */
		unsigned int index;

		/* The wifi-specific timestamp for this scan line */
		unsigned int wifi_time_sec; /* seconds component */
		unsigned int wifi_time_usec; /* microseconds component */
		unsigned long long windows_time; /* windows time (cycles) */

		/* beacon information */
		short bssid[BSSID_SIZE];
		unsigned short freq; /* frequency (MHz) */
		unsigned char tag_num; /* tag number of frame */
		std::string ssid; /* name of network */

		/* signal information */
		char sig_level;


	/* functions */
	public:

		/* constructors */

		/**
		 * Initializes empty frame
		 */
		wifi_frame_t();

		/**
		 * Frees all memory and resources
		 */
		~wifi_frame_t();

		/* initialization */

		/**
		 * Will parse the next scan block out of a binary stream
		 *
		 * The stream is assumed to be a wifi data file, positioned
		 * at the start of a scan block.  The scan block will be
		 * parsed based to populate this struct.
		 *
		 * @param is           The binary stream to read and parse
		 *
		 * @returns    Returns zero on success, non-zero on failure
		 */
		int parse(std::istream& is);
};

/**
 * This defines the wifi_reader_t class to parse a binary wifi data file
 */ 
class wifi_reader_t
{
	/* parameters */
	private:

		/* the binary file to parse */
		std::ifstream infile;

		/* the number of frames read so far from the file */
		unsigned int next_index;

		/* the version numbers of the file */
		char major_version;
		char minor_version;

		/* scanner hardware information */
		std::string antenna_name;

		/* size of file */
		unsigned int num_scans;

	/* functions */
	public:

		/* constructors */

		/**
		 * Constructs empty class
		 */
		wifi_reader_t();

		/**
		 * Frees all allocated memory and resources
		 */
		~wifi_reader_t();

		/**
		 * Open file for parsing. Verifies file correctly formatted.
		 *
		 * Will open the selected file, and read the header of
		 * this file.  Will only return success if the file
		 * is verified to be a wifi binary data file.  After
		 * this is called, will be ready to read scan frames from
		 * file.
		 *
		 * @param filename The path the wifi binary data file
		 *
		 * @returns     Returns zero on success, non-zero on failure
		 */
		int open(const std::string& filename);

		/**
		 * Returns the antenna name from the open file
		 *
		 * Will return the parsed antenna name from the header
		 * of the open file.
		 *
		 * @returns    Returns string of the antenna name
		 */
		inline std::string get_antenna_name() const
		{
			return this->antenna_name;
		};

		/**
		 * Returns the number of scans contained in this file
		 *
		 * Will return the number of written scans in the file,
		 * based on the value stored in the file header.
		 *
		 * @returns    Returns number of wifi packet scans
		 */
		inline unsigned int get_num_scans() const
		{
			return this->num_scans;
		};

		/**
		 * Parses the next frame from the file
		 *
		 * Will read the next frame from the file and populate
		 * the specified frame struct with its information.
		 *
		 * @param frame The struct to populate with the next frame
		 *
		 * @returns     Returns zero on success, non-zero on failure
		 */
		int next(wifi_frame_t& frame);

		/**
		 * Returns true iff end of file reached.
		 *
		 * Will pass the eof flag from the file stream as
		 * the return value of this function.
		 *
		 * @returns     Returns true iff end-of-file reached
		 */
		bool eof() const;

		/**
		 * Closes the stream and frees resources
		 *
		 * Will close any open file streams and free allocated
		 * arrays in memory.
		 */
		void close();
};

#endif
